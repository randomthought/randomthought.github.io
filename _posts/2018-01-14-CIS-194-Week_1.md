---
layout: post
title: "CIS 194: Intro to Haskell (Spring 2013) Week 1 Solutions"
date: "2018-01-14"
slug: "example_content"
description: "Example content from lanyon. If page description is more than 140 words, it will be shown as post summary on home page and blog index else post excerpt will be shown. Same rule is for html meta description: >140 words in description or first 50 words of posts will be shown as summary. Page excerpt supports markdown formatted summary."
category: 
  - views
  - featured
# tags will also be used as html meta keywords.
tags:
  - haskell
show_meta: true
comments: true
mathjax: true
gistembed: true
published: true
noindex: false
nofollow: false
# hide QR code, permalink block while printing.
hide_printmsg: false
# show post summary or full post in RSS feed.
summaryfeed: false
## for twitter summary card with squared image and page description or page excerpt:
# imagesummary: foo.png
## for twitter card with large image:
## for twitter video card: (active for this page**
---
**Exercise 1** We need to first find the digits of a number. Define the functions

```
toDigits    :: Integer -> [Integer]
toDigitsRev :: Integer -> [Integer]
```
`toDigits `should convert positive Integers to a list of digits. (For 0 or
negative inputs, `toDigits` should return the empty list.) `toDigitsRev`
should do the same, but with the digits reversed.

```
Example: toDigits 1234 == [1,2,3,4] 
Example: toDigitsRev 1234 == [4,3,2,1]
Example: toDigits 0 == []
Example: toDigits (-17) == []
```

**Solution**

{% highlight haskell %}
toDigits :: Integer -> [Integer]
toDigits n
 | n < 1    = []
 | otherwise = toDigits (div n 10) ++ [mod n 10]

toDigitsRev :: Integer -> [Integer]
toDigitsRev n 
    | n < 1     = []
    | otherwise =  mod n 10 : toDigitsRev (div n 10)
{% endhighlight %}
___

**Exercise 2** Once we have the digits in the proper order, we need to
double every other one. Define a function

```
doubleEveryOther :: [Integer] -> [Integer]
```

Remember that doubleEveryOther should double every other number
beginning from the right, that is, the second-to-last, fourth-to-last,
... numbers are doubled.

```
Example: doubleEveryOther [8,7,6,5] == [16,7,12,5]
Example: doubleEveryOther [1,2,3] == [1,4,3]
```

**Solution**

{% highlight haskell %}
doubleEveryOther :: [Integer] -> [Integer]
doubleEveryOther [] = []
doubleEveryOther (x:[]) = x*2 : []
doubleEveryOther (x:(y:zs)) = x*2 : y : doubleEveryOther zs
{% endhighlight %}
___

**Exercise 3** The output of `doubleEveryOther` has a mix of one-digit
and two-digit numbers. Define the function

```
sumDigits :: [Integer] -> Integer
```

to calculate the sum of all digits.

```
Example: sumDigits [16,7,12,5] = 1 + 6 + 7 + 1 + 2 + 5 = 22
```

**Solution**

{% highlight haskell %}
sumDigits :: [Integer] -> Integer
sumDigits []     = 0
sumDigits (x:xs) 
    | x < 10     = x + sumDigits xs
    | otherwise  = sumDigits(toDigits x) + sumDigits xs
{% endhighlight %}
___

**Exercise 4** Define the function

```
validate :: Integer -> Bool
```

that indicates whether an Integer could be a valid credit card number.
This will use all functions defined in the previous exercises.

```
Example: validate 4012888888881881 = True
Example: validate 4012888888881882 = False
```


**Solution**

{% highlight haskell %}
validate :: Integer -> Bool
validate n = sumDigits (doubleEveryOther (toDigits n)) `mod` 10 == 0
{% endhighlight %}
---

**Exercise 5** The Towers of Hanoi is a classic puzzle with a solution
that can be described recursively. Disks of different sizes are stacked
on three pegs; the goal is to get from a starting configuration with
all disks stacked on the first peg to an ending configuration with all
disks stacked on the last peg.

{% include youtube.html id="WPSeyjX1-4s?t=20m10s" %}

For this exercise, define a function hanoi with the following type:

```
type Peg = String
type Move = (Peg, Peg)
hanoi :: Integer -> Peg -> Peg -> Peg -> [Move]
```

**Solution**

{% highlight haskell %}
type Peg = String
type Move = (Peg, Peg)

hanoi :: Integer -> Peg -> Peg -> Peg -> [Move]
hanoi 0 a b c = []
hanoi 1 a b c = [(a, c)]
hanoi 2 a b c = (a, b) : (a, c) : [(b, c)]
hanoi n a b c = (a, c) : (a, b) : (c, b) : (a, c) : hanoi (n-1) b a c
{% endhighlight %}
